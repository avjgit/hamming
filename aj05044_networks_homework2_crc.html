Andrejs Jurčenoks, stud.apl.nr. aj05044.
<h2>Datoru tīkli I 2.mājas darbs</h2>
<small><strong>Uzdevums:</strong> Izlasit no Tanenbauma gramatas nodalu "3.2 Error Detection and Correction" par CRC un Haminga kodu. Jebkura programmesanas valoda noprogrammet Haminga kodu un CRC un uz 5 piemeriem nodemonstret tos darbiba. Isuma paskaidrot kas tiek darits un kadas kludas piemeros tiek/netiek izlabotas vai pamanitas. 
</small>
<h3>2. daļa (no 2), CRC algoritms.</h3>

Realizēts inteaktīvs rīks, kas ļauj ievadīt patvaļīgus bitus iekodēšanai un atkodēšanai, izmantojot CRC algoritmu.
Ievadiet sūtāmos bitus, tad rediģējiet (vai nemainiet) sūtāmos bitus (tiek ģenerēts automātiski) 
un nospiediet pogu "Dekodēt" - rezultāts būs zemāk, žurnālierakstos.
Žurnālierakstos (logā) ir arī redzami automātiski izlaisti testpiemēri.

<p><small><strong>Komentārs:</strong> kods uzrakstīts Javascript valodā, izmantojot dažas ECMAScript 2015 (ES6) versijas funkcijas (gatavu Math.log2, forEach uc); pārbaudīts Chrome 77 versijā (valodas atbalsts pārlūkos: https://caniuse.com/#search=es6).</small></p>

Ievadiet sūtāmos bitus (tikai 0 un 1, piem., 01110101):<br/>
<input id="sendingBits" oninput="setCRC()"><br/>
Tiek nosūtīti biti<br/>
<input id="wordSent" disabled><br/>
Ievadiet saņemtos bitus:<br/>
<small>tie var būt gan tieši tādi paši, kā nosūtīti (bez kļūdām), gan atšķirties no nosūtītiem (simulējot pārraides kļūdu)</small><br/>
<input id="wordReceived"><br/>
<p><input type="submit" onClick="decodeCRC()" value="Dekodēt"></p>
Dekodēti sūtītie biti:<br/>
<input id="bitsDecoded" disabled><br/>
Log:
<ul id = "log">
</ul>

<script type="text/javascript">
function datetime(){
    var today = new Date();
    var date = today.getFullYear()+'-'+(today.getMonth()+1)+'-'+today.getDate();
    var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
    return date+' '+time;
}

function setCRC(){
    const sendingBits = document.getElementById('sendingBits').value;
    const wordSentField = document.getElementById('wordSent');
    const wordReceivedField = document.getElementById('wordReceived');
    wordSentField.value = encode(sendingBits, '10101').join('');
    wordReceivedField.value = wordSentField.value;
}
function decodeCRC() {
    const bits = document.getElementById('sendingBits').value;
    const sent = document.getElementById('wordSent').value;
    const received = document.getElementById('wordReceived').value;
    document.getElementById('bitsDecoded').value = crcBackend(bits, sent, received, '10101');
}
function crcBackend(bits, sent, received, generator, description = ''){
    let decoded = decode(received, generator);
    let logText = datetime() 
    + ' ' + description
    + " sūtāmie biti " + bits + " tika nosūtīti kā " + sent
    + ", saņemti kā " + received + "; atšifrēts ziņojums " + decoded[0] + ", pamanītas " + decoded[1] + " kļūdas";

    var textnode = document.createTextNode(logText);         
    var node = document.createElement("li");   
    node.appendChild(textnode);
    document.getElementById("log").appendChild(node);
    return decoded[0];
}
//https://www.geeksforgeeks.org/modulo-2-binary-division/
function modulo2division (divident, divisor) {
    let part = divisor.length;
    let tmp = divident.slice(0, part);
    while (part < divident.length) {
        tmp = tmp.charAt(0) === '1'
            ? tmp = xor(divisor, tmp) + divident.charAt(part)
            : tmp = xor('0'.repeat(part), tmp) + divident.charAt(part);
        part += 1;      
    }
    tmp = tmp.charAt(0) === '1'
        ? tmp = xor(divisor, tmp)
        : tmp = xor('0'.repeat(part), tmp);
    return tmp;
};

function xor (a, b) {
    const result = [];
    for (let i = 1; i < b.length; i++) result.push(a.charAt(i) === b.charAt(i) ? '0' : '1');
    return result.join('');
};

function encode(bitsSent, generator) {
    const frames = [];
    bitsSent.split("").map(Number).forEach(byte => {
        const appendedByte = byte + '0'.repeat(generator.length - 1);
        const remainder = modulo2division(appendedByte, generator);
        frames.push((byte + remainder).split('').map(item => parseInt(item, 10)));
    });
    return frames;
};

function decode(frames, generator) {
    const arrayOfBytes = [];
    let errorsCount = 0;
    frames.forEach(frame => {
        if (modulo2division(frame.join(''), generator) !== '0'.repeat(generator.length - 1)) {
          errorsCount++;
        }
        arrayOfBytes.push(frame.slice(0, -(generator.length - 1)));
    });
    return [arrayOfBytes.join(''), errorsCount];
};

function cyclicRedundancyCheck (bitsSent) {
    const generator = '10101';
    const sent = encode(bitsSent, generator);
    const received = sent; //todo: error
    const decoded = decode(received, generator);
    console.log('Nosūtīts:  ', bitsSent);
    console.log('Dešifrēts: ', decoded[0]);
    console.log('Pamanītu kļūdu skaits: ', decoded[1]);
};

cyclicRedundancyCheck("100100");
</script>
